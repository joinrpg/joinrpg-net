@using System.Linq.Expressions
@inject ICharactersClient client

@if (items is null)
{
   <JoinLoadingMessage />
}
else
{
  int[] initial = SelectedCharacterIds is not null ? [..SelectedCharacterIds.Select(x => x.CharacterId)] : [];
  <IntSelector
               Name="@Name"
               SelectedValues="initial"
               SelectedValuesChanged="SelectedValuesChanged"
               PossibleValues="items"
               Multiple="@Multiple"
               />
  <p>@SelectedCharactersText</p>
}

@code {

    [CascadingParameter] public EditContext? EditContext { get; set; }
    [Parameter] public string? Name { get; set; } = null;
    [Parameter] [EditorRequired] public int ProjectId { get; set; }

    [Parameter] public CharacterIdentification[] SelectedCharacterIds { get; set; } = [];
    [Parameter] public EventCallback<CharacterIdentification[]> SelectedCharacterIdsChanged { get; set; }
    [Parameter] public Expression<Func<CharacterIdentification?>>? SelectedCharacterIdsExpression { get; set; }

    [Parameter] public EventCallback<CharacterDto[]> SelectedCharactersChanged { get; set; }
    [Parameter] public bool Multiple { get; set; } = true;
    [Parameter] public bool TemplateOnly { get; set; } = false;
    [Parameter] public bool AllowEmpty { get; set; } = false;

    public string SelectedCharactersText{ get; private set; } = "";

    private IntSelectListItem[] items = null!;
    private List<CharacterDto> chars = null!;
    private FieldIdentifier? fieldIdentifier = null;

    private async Task SelectedValuesChanged(int[] values)
    {
        values = [..values.Where(v => v != -1)];

        var selectedItems = chars.Where(item => values.Contains(item.CharacterId.CharacterId)).ToArray();
        RefreshSelectedNames(selectedItems);
        await SelectedCharacterIdsChanged.InvokeAsync(selectedItems.Select(x => x.CharacterId).ToArray());
        await SelectedCharactersChanged.InvokeAsync(selectedItems);

        if (EditContext is not null && fieldIdentifier is not null)
        {
            EditContext.NotifyFieldChanged(fieldIdentifier.Value);
        }
    }

    private void RefreshSelectedNames(CharacterDto[] val)
    {
        if (val.Length < 2)
        {
            SelectedCharactersText = "";
        }
        else
        {
            SelectedCharactersText = string.Join(" • ", val.Select(item => item.Name));
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        chars = TemplateOnly
          ? await client.GetTemplateCharacters(ProjectId) 
          : await client.GetCharacters(ProjectId);
        var selectedItems = chars.Where(item => SelectedCharacterIds.Contains(item.CharacterId)).ToArray();
        if (AllowEmpty)
        {
            var empty = new IntSelectListItem(-1, "(нет)");
            items = [empty, .. chars.Select(ToSelectListItem)];
        }
        else {
            items = [.. chars.Select(ToSelectListItem)];
        }
        RefreshSelectedNames(selectedItems);

        if (SelectedCharacterIdsExpression is not null)
        {
            fieldIdentifier = FieldIdentifier.Create(SelectedCharacterIdsExpression);
            Name ??= fieldIdentifier.Value.FieldName;
        }
    }

    private static IntSelectListItem ToSelectListItem(CharacterDto item)
    {
        return new IntSelectListItem(
          Value: item.CharacterId.CharacterId,
          Text: item.Name,
          Subtext: item.Description,
          ExtraSearch: "");
    }
}
